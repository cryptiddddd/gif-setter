#!/usr/bin/bash

NAME="gif-set"
VERSION="1.0"

USER_CONFIG="~/.config/$NAME.conf"
LOCAL_CONFIG="./$NAME.conf"

BATCH_DIR="./output"

# pretty helpers
info() { [ $VERBOSE ] && echo -e "\033[1;38mü´ê  $1\033[0m"; }
success() { echo -e "\033[1;32mü•ù $1\033[0m"; }
error() { echo -e "\033[1;31müçì $1\033[0m"; }


help() {
    cat << EOL 
${NAME} ${VERSION}
Basic tool to create gifs from a video file. Programmable via optional parameters, and user & local config files. Optional batch functionality.
    
USAGE: ./${NAME} [OPTIONS...] OUTPUT_PATH

ACTIONS
    --help, -h: View this help menu.
    --verbose, -V: Print additional status updates.

PARAMETERS:
    OUTPUT_PATH: Filepath for output. May be supplied by batch or config file.

OPTIONS:
    --input, -I [INPUT PATH]: Path for input file. While required information, the CLI parameter is optional, given the preferred method of setting via a config file.
    --start, -S [TIMESTAMP]: Starting timestamp.
    --length, -l [DIRECTORY]: Duration of the GIF to create, in seconds.
    --dimensions, -D [WIDTH]x[HEIGHT]: Dimensions of the GIF output.
    --config, -c [PATH]: Path to a custom config file. Will be used on top of local and user configs.

BATCH OPTIONS:
    --batch, -b [PATH]: Path to CSV file with batch information. See README for more.
    --batch-index, -i [INDICES,...]: Pick-and-choose entries from the batch file by line number. Multiple are allowed, comma-separated. (Ignored if used without "--batch" flag.)
    
Crane Presents... ${NAME}, ${VERSION}
EOL
    exit 0
}


batch() {
    line_count=1
    mkdir -p "$BATCH_DIR"


    while IFS="," read -r name start length
    do
        if [ -z "$BATCH_INDICES" ] || [[ $(echo "$BATCH_INDICES" | grep -w "$line_count") ]]; then
            OUTPUT_PATH="$BATCH_DIR/$name.gif"
            START_TIME=$start
            DURATION=$length
            render &

            pids+=($!)
        fi

        ((line_count++))

    done < $BATCH_PATH
}

render() {
    info "Queueing render for '$OUTPUT_PATH' ..."

    ffmpeg -y -v quiet -ss "$START_TIME" -t "$DURATION" -i "$INPUT_FILE" -s "$DIMENSIONS" "$OUTPUT_PATH" &>/dev/null

    pid+=("$!")

    # log
    if [ $? -eq 0 ]; then
        success "Rendered '$OUTPUT_PATH' !"
    else
        error "RENDER NOT VALIDATED."    
    fi
}


# Iterate through all arguments, parsing flags.
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            help
            ;;
        -V|--verbose)
            VERBOSE=true
            shift
            ;;
        
        -I|--input)
            INPUT_FILE="$2"
            shift
            shift
            ;;
        
        -S|--start)
            START_TIME="$2"
            shift
            shift
            ;;

        -l|--length)
            DURATION="$2"
            shift
            shift
            ;;

        -D|--dimensions)
            DIMENSIONS="$2"
            shift
            shift
            ;;

        -b|--batch)
            BATCH_PATH="$2"
            shift
            shift
            ;;

        -i|--batch-index)
            BATCH_INDICES=$(echo "$2" | tr "," " ")
            shift
            shift
            ;;
        
        -c|--config)
            CUSTOM_CONFIG="$2"
            shift
            shift
            ;;

        -*|--*)
            echo "Option $1 not recognized"
            exit 1
            ;;
            
        *)
            OUTPUT_PATH="$1"
            shift
            ;;
    esac
done


for conf in "$USER_CONFIG" "$LOCAL_CONFIG" "$CUSTOM_CONFIG"; do
    if [ -f "$conf" ]; then
        info "Using configuration from $conf ..."
        source "$conf"
    fi
done


pids=()


if [ "$BATCH_PATH" ]; then
    batch
else
    for i in START_TIME DURATION INPUT_FILE DIMENSIONS OUTPUT_PATH; do
        if [ -z ${!i} ]; then
            error "Parameter $i is missing!"
            exit 1
        fi
    done
    render
fi

# await all child processes
for pid in ${pids[*]}; do
    wait $pid
done
